trigger: none

resources:
  repositories:
    - repository: self
      type: github
      name: Action1Corp/PSAction1
      endpoint: 'Action1 GitHub'
      branch: 'main'

pool:
  vmImage: 'windows-latest'

jobs:
- job: SignScripts
  displayName: 'Sign scripts'
  steps:

    - checkout: self
      clean: true
      fetchDepth: 0
      persistCredentials: true

    - task: AzureKeyVault@2
      displayName: 'Establish KeyVault Connection'
      inputs:
        azureSubscription: 'Action1 Azure'
        KeyVaultName: 'a1-codesign-kv'
        SecretsFilter: 'codesign-globalsign-2'
        RunAsPreJob: false

    - task: AWSShellScript@1
      displayName: 'Get codesign cert'
      inputs:
        awsCredentials: 'Action1 AWS'
        regionName: 'us-east-1'
        scriptType: 'inline'
        inlineScript: |
          #SECRET=$(aws secretsmanager get-secret-value --secret-id a1-devops/a1-builder/codesigncert --query SecretString --output text)
          #BASE64_PFX=$(echo "$SECRET" | jq -r ".codesigncert")
          #PFX_PASS=$(echo "$SECRET" | jq -r ".codesigncertpass")
          #echo "$BASE64_PFX" | base64 --decode > "$(Build.SourcesDirectory)/cert.pfx"
          #echo "##vso[task.setvariable variable=PFX_PASS;issecret=true]$PFX_PASS"

    - task: PowerShell@2
      displayName: 'Sign PowerShell Files'
      inputs:
        targetType: inline
        script: |
          $PFX_PATH = "$(Build.SourcesDirectory)\cert.pfx"
          Write-Host "PFX_PATH = $PFX_PATH"
          [System.IO.File]::WriteAllBytes($PFX_PATH, [Convert]::FromBase64String("$(codesign-globalsign-2)"))
          if([System.IO.File]::Exists($PFX_PATH))
          {
            Write-Host "$PFX_PATH exists"
          }
          else
          {
            Write-Host "$PFX_PATH doesn't exist"
          }
          try {
              #$keyStorageFlags = [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::PersistKeySet `
              #     -bor [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable
              #$certificate = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2(
              #  $PFX_PATH,
              #  "$(PFX_PASS)",
              #  $keyStorageFlags
              #)
          }
          catch {
              Write-Host "##vso[task.logissue type=error;]Failed to load PFX certificate: $($_.Exception.Message)"
              Write-Host "##vso[task.complete result=Failed;]Failed to load PFX certificate: $($_.Exception.Message)"
              exit 1
          }
          $certificate = Import-PfxCertificate -FilePath $PFX_PATH -CertStoreLocation Cert:\CurrentUser\My
          Get-ChildItem -Path $Directory -Recurse -Include *.ps1, *.psm1, *.psd1 -File |
          ForEach-Object {
              Write-Host "Signing: $($_.FullName)"
              try {
                  $signResult = Set-AuthenticodeSignature -FilePath $_.FullName -Certificate $certificate -TimestampServer "http://timestamp.digicert.com" -ErrorAction Stop
                  Write-Host "Signature Status: $($signResult.Status)"
                  # Uncomment when the production certificate is added. For now the step fails because self-signed certificate is in use
                  # Purchase a separate codesign certificate?
                  #if ($signResult.Status -eq 'Valid') {
                      Write-Host "Successfully signed: $($_.FullName)"
                      Copy-Item $_.FullName -Destination $env:Build_ArtifactStagingDirectory
                  #} else {
                  #    Write-Host "##vso[task.logissue type=error;]Signed but encountered status '$($signResult.Status)': $($_.FullName)"
                      #Write-Host "##vso[task.complete result=Failed;]Signed but encountered status '$($signResult.Status)': $($_.FullName)"
                      #exit 1
                  #}
              }
              catch {
                  Write-Host "##vso[task.logissue type=error;]Failed to sign '$($_.FullName)': $($_.Exception.Message)"
                  Write-Host "##vso[task.complete result=Failed;]Failed to load PFX certificate: $($_.Exception.Message)"
                  exit 1
              }
          }
      env:
        PFX_PASS: $(PFX_PASS)

    - task: PowerShell@2
      displayName: 'Create Branch, Modify Files, and Push'
      inputs:
        targetType: 'inline'
        script: |          
          $branchName = "signed-$(Get-Date -Format 'yyyyMMddHHmmss')"
          $repoUrl = "$(Build.Repository.Uri)"
          $email = "github@action1.com"
          $username = "github-action1[bot]"
          
          $githubToken = $GITHUB_TOKEN
          
          git config --global user.email "$email"
          git config --global user.name "$username"
          
          git checkout -b $branchName
          
          $filePath = "README.md"
          if (Test-Path $filePath) {
            Add-Content -Path $filePath -Value "`nModified on $(Get-Date)"
          } else {
            New-Item -Path $filePath -ItemType File -Value "This is a new file added on $(Get-Date)"
          }
          
          git add .
          git commit -m "Automated commit: Modified files in branch $branchName"
          
          git remote set-url origin https://x-access-token:$githubToken@github.com/$(Build.Repository.Name).git
          git push origin $branchName

          Write-Host "Branch '$branchName' created and pushed successfully."

      env:
        GITHUB_TOKEN: $(System.AccessToken)

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Internally'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: 'release'
        publishLocation: 'Container'
